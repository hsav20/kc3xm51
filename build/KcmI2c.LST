C51 COMPILER V6.14  KCMI2C                                                                 06/09/2020 11:19:52 PAGE 1   


C51 COMPILER V6.14, COMPILATION OF MODULE KCMI2C
OBJECT MODULE PLACED IN KcmI2c.OBJ
COMPILER INVOKED BY: D:\SDK\kc3xm51\Tools\C51.EXE KcmI2c.c SMALL WL(1) 

stmt level    source

   1          
   2          // Copyright (c) 2002-2020, Hard & Soft Technology Co.,LTD.
   3          // SPDX-License-Identifier: Apache-2.0
   4          // https://gitee.com/hsav20/kc3xm51.git
   5          // https://github.com/hsav20/kc3xm51.git
   6          // http://www,hsav.com/download/kc3xm51.zip
   7          
   8          #include "main.h"           
   9          
  10          //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -////////
  11          // Media Hardware interface //////////////////////////////////////////////////////////////////////////////
             -//////
  12          //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -////////
  13          void MKCM_WriteRegister(					  				// 写DA32Ux的I2C寄存器, 成功返回1
  14          					BYTE address, 							// 地址索引值
  15          					BYTE vaule){ 							// 数据
  16   1      	MI2C_Bus_Start();										// I2C Start
  17   1      	MI2C_Bus_Write(cI2C_ADDRESS);							// KCM I2C address
  18   1      	MI2C_Bus_Write(address);							// Index 写入I2C从机的寄存器索引值
  19   1      	MI2C_Bus_Write(vaule);								// Data 写入I2C从机的数据
  20   1      	MI2C_Bus_Stop();										// I2C Stop
  21   1          return;
  22   1      }
  23          void MKCM_Write2Byte(										// Write 2 bytes to DA32C. 写入2个字节
  24          					BYTE address,    						// Index. 寄存器索引值
  25          					WORD vaule){      						// 16 bit Data. 16位数据
  26   1      	MI2C_Bus_Start();										// I2C Start
  27   1      	MI2C_Bus_Write(cI2C_ADDRESS);							// KCM I2C address
  28   1      	MI2C_Bus_Write(address);							// Index. 写入I2C从机的寄存器索引值
  29   1      	MI2C_Bus_Write(vaule);								// Low byte data. 写入I2C从机的低字节数据
  30   1      	MI2C_Bus_Write(vaule >> 8);							// High byte data. 写入I2C从机的高字节数据
  31   1      	MI2C_Bus_Stop();										// I2C Stop
  32   1      	return;
  33   1      }
  34          void MKCM_WriteXByte(										// Write buffer to DA32C. 写入多个字节
  35          					BYTE address,   						// Index. 寄存器索引值
  36          					WORD length,    						// Length. 长度
  37          					BYTE* in_data){ 						// Buffer address. 数据缓冲
  38   1      	MI2C_Bus_Start();										// I2C Start
  39   1      	MI2C_Bus_Write(cI2C_ADDRESS);							// KCM I2C address
  40   1      	MI2C_Bus_Write(address);							// Index. 写入I2C从机的寄存器索引值
  41   1      	do { 
  42   2      		MI2C_Bus_Write(*in_data++);						// Write byte data. 写入I2C从机的数据
  43   2      	} while (--length != 0);
  44   1      	MI2C_Bus_Stop();										// I2C Stop
  45   1      	return;
  46   1      }
  47          
  48          BYTE MKCM_ReadRegister(										// Read byte from DA32C. 读取8位的寄存器
  49          					BYTE address){     						// Index. 寄存器索引值
  50   1      	BYTE gLocal_1 = 0;
  51   1      	MI2C_Bus_Start();										// I2C Start
  52   1      	MI2C_Bus_Write(cI2C_ADDRESS);							// KCM I2C address
C51 COMPILER V6.14  KCMI2C                                                                 06/09/2020 11:19:52 PAGE 2   

  53   1      	if (!FKCM_I2C_Error){
  54   2      		MI2C_Bus_Write(address);							// Index. 写入I2C从机的寄存器索引值
  55   2      	//	MI2C_Bus_Stop();										// I2C Stop
  56   2      	//	MUSDELAY(10);											// delay 10us
  57   2      		MI2C_Bus_Start();									// I2C Start
  58   2      		MI2C_Bus_Write(cI2C_ADDRESS+1);						// KCM I2C read address
  59   2      	//gLocal_1 = MI2C_Bus_Read(0);							// Read 1 byte 
  60   2      	//MDEBUG(gLocal_1);
  61   2      	    gLocal_1 = MI2C_Bus_Read(1);							// Read 1 byte 
  62   2      //MDEBUG(gLocal_1);
  63   2      	}
  64   1      	MI2C_Bus_Stop();										// I2C Stop
  65   1      	return gLocal_1;
  66   1      }
  67          WORD MKCM_Read2Byte(										// Read word from DA32C. 读取16位的寄存器
  68          					BYTE address){     						// Index. 寄存器索引值
  69   1          WORD g2Local_1 = 0;
  70   1      	MI2C_Bus_Start();										// I2C Start
  71   1      	MI2C_Bus_Write(cI2C_ADDRESS);							// KCM I2C address
  72   1      	if (!FKCM_I2C_Error){
  73   2      		MI2C_Bus_Write(address);								// Index. 写入I2C从机的寄存器索引值
  74   2      	//	MI2C_Bus_Stop();										// I2C Stop
  75   2      	//	MUSDELAY(10);											// delay 10us
  76   2        
  77   2      		MI2C_Bus_Start();									// I2C Start
  78   2      		MI2C_Bus_Write(cI2C_ADDRESS+1);						// KCM I2C read address
  79   2      	    g2Local_1 = MI2C_Bus_Read(0);						// Read 1 byte 
  80   2      	    g2Local_1 = g2Local_1 | (MI2C_Bus_Read(1) << 8);	// Read last byte 
  81   2      	}
  82   1      	MI2C_Bus_Stop();										// I2C Stop
  83   1      	return g2Local_1;
  84   1      }
  85          
  86          void MKCM_ReadXByte(										// Read buffer from DA32C. 读取多个字节
  87          					BYTE address,   						// Index. 寄存器索引值
  88          					WORD length,    						// Length. 长度
  89          					BYTE* out_data){      					// Buffer 数据缓冲
  90   1      	MI2C_Bus_Start();										// I2C Start
  91   1      	MI2C_Bus_Write(cI2C_ADDRESS);							// KCM I2C address
  92   1      //	if (!FKCM_I2C_Error){
  93   1      		MI2C_Bus_Write(address);								// Index. 写入I2C从机的寄存器索引值
  94   1      	//	MI2C_Bus_Stop();										// I2C Stop
  95   1      	//	MUSDELAY(10);											// delay 10us
  96   1      
  97   1      		MI2C_Bus_Start();									// I2C Start
  98   1      		MI2C_Bus_Write(cI2C_ADDRESS+1);						// KCM I2C read address
  99   1      		if (length > 1){									// 防止只有一次时g2Local_1变为0产生跨界错误
 100   2      			length = length - 1;							// Counter. 做少一次，最后的字节使用MI2C_Bus_Read(1);
 101   2      		}
 102   1      		do {													
 103   2      		    *out_data++ = MI2C_Bus_Read(0);					// Read 1 byte 
 104   2      		} while (--length != 0);
 105   1      	    *out_data = MI2C_Bus_Read(1);						// Read last byte 
 106   1      //	}
 107   1      	MI2C_Bus_Stop();										// I2C Stop
 108   1      	return;
 109   1      }
 110              
 111          void MI2C_Bus_Write(BYTE gLocal_1){      					// 往I2C总线写入一个字节，gLocal为待写数据
 112   1          BOOL FLocal_1;											// 返回成功/失败标志
 113   1          BYTE gLocal_2;											// 位计数器
 114   1            
C51 COMPILER V6.14  KCMI2C                                                                 06/09/2020 11:19:52 PAGE 3   

 115   1          gLocal_2 = 8;											// 8位，高位先出
 116   1          do { 
 117   2              HAL_KCM_I2C_SCL(0);									// 置低I2C时钟线，以改变数据
 118   2              if (gLocal_1 & 0x80){								// 如果数据位为1
 119   3                  HAL_KCM_I2C_SDA(1);								// 置高I2C数据线
 120   3              }
 121   2              else {												// 如果数据位为0
 122   3                  HAL_KCM_I2C_SDA(0);								// 置低I2C数据线
 123   3              }
 124   2      	    MI2C_400K_DELAY();									// 按照400Kbps的标准延时，可以有效地提高通讯的速度
 125   2              gLocal_1 <<= 1;										// 准备下一位数据
 126   2              HAL_KCM_I2C_SCL(1);									// 置高I2C时钟线，保持数据稳定
 127   2      	    MI2C_400K_DELAY();									// 按照400Kbps的标准延时，可以有效地提高通讯的速度
 128   2          } while (--gLocal_2 != 0);								// 完成8位数据
 129   1          HAL_KCM_I2C_SCL(0);										// 置低I2C时钟线，准备ACK位
 130   1          HAL_KCM_I2C_SDA(1);										// 将SDA设置为输入
 131   1          MI2C_100K_DELAY();										// 按照100Kbps的标准延时，以确保状态稳定
 132   1          HAL_KCM_I2C_SCL(1);										// 置高I2C时钟线
 133   1          MI2C_100K_DELAY();										// 按照100Kbps的标准延时，以确保状态稳定
 134   1      	FKCM_I2C_Error = 0;                                     // ACK标志表示成功
 135   1          if ((HAL_KCM_I2C_IN_SDA())){							// 高为NAK
 136   2              FKCM_I2C_Error = 1;                                 // NAK标志表示从机没有应答，可能是硬件故障
 137   2          }
 138   1          HAL_KCM_I2C_SCL(0);                                            
 139   1          MI2C_100K_DELAY();										// 按照100Kbps的标准延时，以确保状态稳定
 140   1          return;                                        			// 返回cI2C_NCK/cI2C_ACK标志
 141   1      }
 142          BYTE MI2C_Bus_Read(BOOL FLocal_NAK){						// 从I2C总线读一个字节，在最后一次读时，FLocal_NAK必须为1
 143   1          BYTE gLocal_1;											// 数据暂存器 
 144   1          BYTE gLocal_2;											// 位计数器
 145   1      
 146   1          HAL_KCM_I2C_SDA(1);                                     // 将SDA设置为输入
 147   1          MI2C_100K_DELAY();										// 按照100Kbps的标准延时，以确保状态稳定
 148   1          gLocal_2 = 8;											// 8位
 149   1          do{														
 150   2              HAL_KCM_I2C_SCL(1);									// 置高I2C时钟线，时钟线为高电平时数据方有效
 151   2              gLocal_1 <<= 1;										// 向左移一位，第0位为0
 152   2              if ((HAL_KCM_I2C_IN_SDA())){
 153   3              	gLocal_1 |= 0x01;                				// 如果数据线为高电平，则数据暂存器的第0位赋1
 154   3      	    }
 155   2      	    MI2C_400K_DELAY();									// 按照400Kbps的标准延时，可以有效地提高通讯的速度
 156   2              HAL_KCM_I2C_SCL(0);									// 置低I2C时钟线，接收下一位
 157   2      	    MI2C_400K_DELAY();									// 按照400Kbps的标准延时，可以有效地提高通讯的速度
 158   2          } while (--gLocal_2 != 0);								// 循环8次，完成一个字节的接收
 159   1            
 160   1          if (!FLocal_NAK){										// 如果ACK标志为0
 161   2              HAL_KCM_I2C_SDA(0);									// 置低数据线，ACK为0，继续读取
 162   2          }
 163   1          else {													// 如果ACK标志为1
 164   2              HAL_KCM_I2C_SDA(1); 								// 置高数据线，ACK为1，读取结束
 165   2          }
 166   1          MI2C_100K_DELAY();										// 按照100Kbps的标准延时，以确保状态稳定
 167   1          HAL_KCM_I2C_SCL(1);
 168   1          MI2C_100K_DELAY();										// 按照100Kbps的标准延时，以确保状态稳定
 169   1          HAL_KCM_I2C_SCL(0);
 170   1          return gLocal_1;
 171   1      } 
 172          void MI2C_Bus_Start(){  									// I2C总线开始
 173   1          HAL_KCM_I2C_SDA(1);                   					// 置高数据线，数据线空闲
 174   1          HAL_KCM_I2C_SCL(1);                   					// 置高时钟线，时钟线空闲
 175   1          MI2C_100K_DELAY();										// 按照100Kbps的标准延时，以确保状态稳定
 176   1          HAL_KCM_I2C_SDA(0);										// 数据线在时钟为高电平时由高电平向低电平切换表示开始
C51 COMPILER V6.14  KCMI2C                                                                 06/09/2020 11:19:52 PAGE 4   

 177   1          MI2C_100K_DELAY();										// 按照100Kbps的标准延时，以确保状态稳定
 178   1          HAL_KCM_I2C_SCL(0);										// 置低时钟线，准备接收或发送数据
 179   1          return;
 180   1      }
 181          void MI2C_Bus_Stop(){										// I2C总线停止
 182   1          HAL_KCM_I2C_SDA(0);                   					// 置低数据线，准备停止
 183   1          MI2C_100K_DELAY();										// 按照100Kbps的标准延时，以确保状态稳定
 184   1          HAL_KCM_I2C_SCL(1);										// 置高时钟线
 185   1          MI2C_100K_DELAY();										// 按照100Kbps的标准延时，以确保状态稳定
 186   1          HAL_KCM_I2C_SDA(1); 									// 数据线在时钟为高电平时由低电平向高电平切换表示结束
 187   1          return;
 188   1      }
 189          void MI2C_100K_DELAY(){										// 按照100Kbps的标准延时，以确保状态稳定
 190   1      	BYTE gLocal_1;
 191   1      	gLocal_1 = 10;
 192   1      	while (--gLocal_1 != 0);
 193   1      }
 194          void MI2C_400K_DELAY(){										// 按照400Kbps的标准延时，可以有效地提高通讯的速度
 195   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    481    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      26
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
