C51 COMPILER V6.14  AUDIO                                                                  06/09/2020 11:19:52 PAGE 1   


C51 COMPILER V6.14, COMPILATION OF MODULE AUDIO
OBJECT MODULE PLACED IN audio.OBJ
COMPILER INVOKED BY: D:\SDK\kc3xm51\Tools\C51.EXE audio.c SMALL WL(1) 

stmt level    source

   1          
   2          // Copyright (c) 2002-2020, Hard & Soft Technology Co.,LTD.
   3          // SPDX-License-Identifier: Apache-2.0
   4          // https://gitee.com/hsav20/kc3xm51.git
   5          // https://github.com/hsav20/kc3xm51.git
   6          // http://www,hsav.com/download/kc3xm51.zip
   7          
   8          #include "main.h"           
   9          
  10          void MAUD_Initialize(){										// 按键模块初始化  	
  11   1      }	  
  12          
  13          //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -/////////
  14          //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -/////////
  15          //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -/////////
  16          void MAUD_10msTimer(BYTE baseTimer){   						// B3=1000ms B2=500ms B1=100ms B0=10ms 
  17   1          return;
  18   1      }
  19          void MAUD_MixInputSource(BYTE index){
  20   1          DIP_SURROUND_OFF();
  21   1          DIP_SRC_FORMAT_OFF();
  22   1      	MAUD_AutoCanclMute();
  23   1      	MAUD_AutoCanclTestTone();
  24   1      	if (gDIP_MenuSelect == cMenu_Restore){					// 只有菜单已经换到cMenu_Restore后，才可以改变当前的输入
  25   2      		if (index == INPUT_SWITCH_NONE){                    // 循环方式
  26   3      			if (++mINPUT_SWITCH > INPUT_SWITCH_H_ARC){
  27   4      				mINPUT_SWITCH = INPUT_SWITCH_AUX;
  28   4      			}
  29   3      		}
  30   2      		else {
  31   3                  gSUB_SrcAuto = INPUT_SWITCH_NONE;               // 自动选择失效
  32   3      			mINPUT_SWITCH = index;
  33   3      		}
  34   2      		MKCM_WriteRegister(KCM_INPUT_SOURCE, MKCM_ToRegister(KCM_INPUT_SOURCE, mINPUT_SWITCH));
  35   2      		MLOG("MixInputSource:%d R:%02x\r\n", (u32)index, (u32)MKCM_ReadRegister(KCM_INPUT_SOURCE));
  36   2      	}else {
  37   2      		MLOG("MixInputSourceB:%d R:%d\r\n", (u32)gDIP_MenuSelect, (u32)cMenu_Restore);
  38   2      	}
  39   1      	MDIP_MenuSelect(cMenu_Restore, MENU_NORMAL);
  40   1      }
  41          void MAUD_MixMasterVolume(BYTE directUp){
  42   1      	BYTE value;
  43   1      
  44   1      	MAUD_AutoCanclTestTone();
  45   1      	FAUD_MasterVolume = 1;
  46   1      	if (directUp){
  47   2              value = 0x30;
  48   2              if (FSYS_MuteEnable){
  49   3      		    FSYS_MuteEnable = 0;
  50   3                  value |= 0x02;                                  // B1为控制音频的静音 B0=0静音关闭 
  51   3              }
  52   2      	}
C51 COMPILER V6.14  AUDIO                                                                  06/09/2020 11:19:52 PAGE 2   

  53   1      	else {
  54   2      		value = 0x20;
  55   2      	}
  56   1      	MKCM_WriteRegister(KCM_VOLUME_MUTE, value);	            // B5为控制音量的加减；B4为0表示音量值减
  57   1      //MDEBUG(0xb1);MDEBUG(value);
  58   1      }
  59          void MAUD_TestToneChannel(BYTE channel){					// 噪音测试
  60   1      	if (channel < 0xff){
  61   2      		MKCM_WriteRegister(KCM_TEST_TONE, 0x10 | MKCM_ToRegister(KCM_TEST_TONE, channel));	// 噪音测试通道
  62   2      //MDEBUG(0xb1);MDEBUG(0x10 | MKCM_ToRegister(KCM_TEST_TONE, channel));
  63   2      	}
  64   1      	else {									 				// 关闭
  65   2      		MKCM_WriteRegister(KCM_TEST_TONE, 0);				// 噪音测试关闭
  66   2      	}
  67   1      }
  68          void MAUD_MixSoundEffect(){
  69   1      	MAUD_AutoCanclMute();
  70   1      	MAUD_AutoCanclTestTone();
  71   1      	if (++gDIP_SoundEffect > 4){
  72   2      		gDIP_SoundEffect = 0;
  73   2      	}
  74   1      	MKCM_WriteRegister(KCM_EQ_SELECT, gDIP_SoundEffect);	// 选择需要的音效处理通道
  75   1      //MDEBUG(0xa7);MDEBUG(gDIP_SoundEffect);
  76   1      }
  77          void MAUD_MixTrimAdjust(BYTE index, BYTE directUp){
  78   1          BYTE address;
  79   1          BYTE value;
  80   1      
  81   1      	MAUD_AutoCanclMute();
  82   1      	if (directUp){
  83   2      		if (gDIP_TrimCtrl[index] < 18){
  84   3      			++gDIP_TrimCtrl[index];
  85   3      		}
  86   2      	}
  87   1      	else {
  88   2      		if (gDIP_TrimCtrl[index] > 0){
  89   3      			--gDIP_TrimCtrl[index];
  90   3      		}
  91   2      	}
  92   1          
  93   1          address = MKCM_ToRegister(KCM_TEST_TONE, index);
  94   1          value = MKCM_ToRegister(KCM_FL_TRIM, gDIP_TrimCtrl[index]);
  95   1      //MDEBUG(0xaa);MDEBUG(index);MDEBUG(KCM_FL_TRIM + address);MDEBUG(value);
  96   1          MKCM_WriteRegister(KCM_FL_TRIM + address, value);
  97   1      }
  98          void MAUD_MixMicAdjust(BYTE index, BYTE directUp){
  99   1      	BYTE value;
 100   1          BYTE temp0;
 101   1      
 102   1      	MAUD_AutoCanclMute();
 103   1          temp0 = index - cMenu_MicVolume1;
 104   1      	if (directUp){
 105   2      		if (gDIP_MicCtrl[temp0] < 9){
 106   3      			++gDIP_MicCtrl[temp0];
 107   3      		}
 108   2      	}
 109   1      	else {
 110   2      		if (gDIP_MicCtrl[temp0] > 0){
 111   3      			--gDIP_MicCtrl[temp0];
 112   3      		}
 113   2      	}
 114   1          switch (index){                                     // 0话筒1音量 1话筒2  2回声 3重复 4延迟 5混响
C51 COMPILER V6.14  AUDIO                                                                  06/09/2020 11:19:52 PAGE 3   

 115   2          case cMenu_MicVolume1:                               // 话筒1音量
 116   2          case cMenu_MicVolume2:                               // 话筒2音量
 117   2              value = MKCM_ToRegister(KCM_MIC_VOLUME, gDIP_MicCtrl[0]);
 118   2              temp0 = MKCM_ToRegister(KCM_MIC_VOLUME, gDIP_MicCtrl[1]);
 119   2              MKCM_WriteRegister(KCM_MIC_VOLUME, temp0 << 4 | value);   // 话筒1及话筒2音量比例
 120   2              break;
 121   2          case cMenu_MicEcho:                                 // 话筒回声比例
 122   2              value = MKCM_ToRegister(KCM_MIC_VOLUME, gDIP_MicCtrl[2]);
 123   2              temp0 = 0;                                  // 话筒多段EQ均衡音效处理选择比例
 124   2              MKCM_WriteRegister(KCM_MIC_ECHO_EQ, temp0 << 4 | value);   // 话筒回声及话筒多段EQ均衡音效处理选择
             -比例
 125   2              break;
 126   2          case cMenu_MicRepeat:                               // 话筒重复比例
 127   2              value = MKCM_ToRegister(KCM_MIC_VOLUME, gDIP_MicCtrl[3]);
 128   2              temp0 = 8;                                  // 直达声比例固定为8
 129   2              MKCM_WriteRegister(KCM_MIC_REPEAT, temp0 << 4 | value);
 130   2              break;
 131   2          case cMenu_MicReverb:                               // 话筒混响比例
 132   2              value = MKCM_ToRegister(KCM_MIC_VOLUME, gDIP_MicCtrl[5]);
 133   2              temp0 = 1;                                  // 话筒混响2固定为1
 134   2              MKCM_WriteRegister(KCM_MIC_REVERB, temp0 << 4 | value);
 135   2              break;
 136   2          case cMenu_MicDelay:                                // 话筒延迟时间，每步20毫秒
 137   2              value = MKCM_ToRegister(KCM_MIC_DELAY, gDIP_MicCtrl[4]);    // 0-255转换到0-9
 138   2              MKCM_WriteRegister(KCM_MIC_DELAY, value);
 139   2              break;
 140   2          }
 141   1      }
 142          void MAUD_AutoCanclTestTone(){
 143   1      //MDEBUG(0xa7);
 144   1      	if (FSYS_TestTone){
 145   2      		FSYS_TestTone = 0;
 146   2      		MKCM_WriteRegister(KCM_TEST_TONE, 0);				// 噪音测试关闭
 147   2      	}
 148   1      
 149   1      }
 150          void MAUD_AutoCanclMute(){
 151   1      	if (FSYS_MuteEnable){
 152   2      		FSYS_MuteEnable = 0;
 153   2      	}
 154   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    587    ----
   CONSTANT SIZE    =     53    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
